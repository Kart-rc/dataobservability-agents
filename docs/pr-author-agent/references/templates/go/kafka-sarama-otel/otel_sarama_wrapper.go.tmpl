// Package otel provides OpenTelemetry instrumentation for Sarama Kafka client.
// Service: ${SERVICE_NAME}
// Generated by: Instrumentation Autopilot
// Diff Plan ID: ${DIFF_PLAN_ID}
package otel

import (
	"context"

	"github.com/IBM/sarama"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/propagation"
	semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
	"go.opentelemetry.io/otel/trace"
)

const (
	serviceName      = "${SERVICE_NAME}"
	serviceNamespace = "${NAMESPACE}"
	consumerGroup    = "${CONSUMER_GROUP}"
	inputTopic       = "${INPUT_TOPIC}"
	outputTopic      = "${OUTPUT_TOPIC}"
)

var tracer = otel.Tracer(serviceName)

// HeadersCarrier implements propagation.TextMapCarrier for Sarama headers
type HeadersCarrier []sarama.RecordHeader

func (c HeadersCarrier) Get(key string) string {
	for _, h := range c {
		if string(h.Key) == key {
			return string(h.Value)
		}
	}
	return ""
}

func (c *HeadersCarrier) Set(key, value string) {
	*c = append(*c, sarama.RecordHeader{
		Key:   []byte(key),
		Value: []byte(value),
	})
}

func (c HeadersCarrier) Keys() []string {
	keys := make([]string, len(c))
	for i, h := range c {
		keys[i] = string(h.Key)
	}
	return keys
}

// ExtractContext extracts trace context from Sarama message headers
func ExtractContext(ctx context.Context, headers []*sarama.RecordHeader) context.Context {
	carrier := make(HeadersCarrier, len(headers))
	for i, h := range headers {
		carrier[i] = *h
	}
	return otel.GetTextMapPropagator().Extract(ctx, carrier)
}

// InjectContext injects trace context into Sarama message headers
func InjectContext(ctx context.Context) []sarama.RecordHeader {
	carrier := HeadersCarrier{}
	otel.GetTextMapPropagator().Inject(ctx, &carrier)

	// Add x-obs-* headers
	carrier.Set("x-obs-dataproduct-urn", "${SERVICE_URN}")

	result := make([]sarama.RecordHeader, len(carrier))
	for i := range carrier {
		result[i] = carrier[i]
	}
	return result
}

// StartConsumerSpan starts a span for consuming a Kafka message
func StartConsumerSpan(ctx context.Context, msg *sarama.ConsumerMessage) (context.Context, trace.Span) {
	// Extract parent context from headers
	ctx = ExtractContext(ctx, msg.Headers)

	ctx, span := tracer.Start(ctx, "consume "+msg.Topic,
		trace.WithSpanKind(trace.SpanKindConsumer),
		trace.WithAttributes(
			semconv.MessagingSystemKafka,
			semconv.MessagingDestinationName(msg.Topic),
			semconv.MessagingKafkaDestinationPartition(int(msg.Partition)),
			attribute.Int64("messaging.kafka.offset", msg.Offset),
			semconv.MessagingKafkaConsumerGroup(consumerGroup),
			semconv.ServiceName(serviceName),
			semconv.ServiceNamespace(serviceNamespace),
		),
	)

	// Extract x-obs-* headers
	for _, h := range msg.Headers {
		key := string(h.Key)
		if len(key) > 6 && key[:6] == "x-obs-" {
			span.SetAttributes(attribute.String("obs."+key[6:], string(h.Value)))
		}
	}

	return ctx, span
}

// StartProducerSpan starts a span for producing a Kafka message
func StartProducerSpan(ctx context.Context, topic string) (context.Context, trace.Span) {
	return tracer.Start(ctx, "produce "+topic,
		trace.WithSpanKind(trace.SpanKindProducer),
		trace.WithAttributes(
			semconv.MessagingSystemKafka,
			semconv.MessagingDestinationName(topic),
			semconv.ServiceName(serviceName),
			semconv.ServiceNamespace(serviceNamespace),
		),
	)
}

// WrapSyncProducer wraps a Sarama SyncProducer with OTel instrumentation
func WrapSyncProducer(producer sarama.SyncProducer) *InstrumentedSyncProducer {
	return &InstrumentedSyncProducer{producer: producer}
}

// InstrumentedSyncProducer is an instrumented Sarama SyncProducer
type InstrumentedSyncProducer struct {
	producer sarama.SyncProducer
}

// SendMessage sends a message with tracing
func (p *InstrumentedSyncProducer) SendMessage(ctx context.Context, msg *sarama.ProducerMessage) (int32, int64, error) {
	ctx, span := StartProducerSpan(ctx, msg.Topic)
	defer span.End()

	// Inject trace context into headers
	headers := InjectContext(ctx)
	msg.Headers = append(msg.Headers, headers...)

	partition, offset, err := p.producer.SendMessage(msg)
	if err != nil {
		span.RecordError(err)
	}

	span.SetAttributes(
		semconv.MessagingKafkaDestinationPartition(int(partition)),
		attribute.Int64("messaging.kafka.offset", offset),
	)

	return partition, offset, err
}

// Close closes the producer
func (p *InstrumentedSyncProducer) Close() error {
	return p.producer.Close()
}
