// Package otel_test provides telemetry validation tests for ${SERVICE_NAME}.
//
// These tests verify:
// - OTel spans are created correctly
// - Trace context is propagated via Kafka headers
// - x-obs-* correlation headers are extracted
//
// Generated by: Instrumentation Autopilot
// Diff Plan ID: ${DIFF_PLAN_ID}
package otel

import (
	"context"
	"testing"

	"github.com/IBM/sarama"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/trace"
	"go.opentelemetry.io/otel/sdk/trace/tracetest"
)

const (
	testTopic         = "${INPUT_TOPIC}"
	testService       = "${SERVICE_NAME}"
	testConsumerGroup = "${CONSUMER_GROUP}"
	testServiceURN    = "${SERVICE_URN}"
)

// setupTestTracer creates a tracer with in-memory span recorder for testing
func setupTestTracer(t *testing.T) (*tracetest.SpanRecorder, func()) {
	sr := tracetest.NewSpanRecorder()
	tp := trace.NewTracerProvider(trace.WithSpanProcessor(sr))
	otel.SetTracerProvider(tp)

	cleanup := func() {
		_ = tp.Shutdown(context.Background())
	}

	return sr, cleanup
}

func TestStartConsumerSpan(t *testing.T) {
	sr, cleanup := setupTestTracer(t)
	defer cleanup()

	// Given a Kafka message with trace context
	msg := &sarama.ConsumerMessage{
		Topic:     testTopic,
		Partition: 0,
		Offset:    100,
		Key:       []byte("test-key"),
		Value:     []byte("test-value"),
		Headers: []*sarama.RecordHeader{
			{
				Key:   []byte("traceparent"),
				Value: []byte("00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
			},
			{
				Key:   []byte("x-obs-dataproduct-urn"),
				Value: []byte(testServiceURN),
			},
		},
	}

	// When we start a consumer span
	ctx, span := StartConsumerSpan(context.Background(), msg)
	span.End()

	// Then a span should be recorded
	spans := sr.Ended()
	require.Len(t, spans, 1)

	recordedSpan := spans[0]
	assert.Equal(t, "consume "+testTopic, recordedSpan.Name())
	assert.NotNil(t, ctx)
}

func TestStartProducerSpan(t *testing.T) {
	sr, cleanup := setupTestTracer(t)
	defer cleanup()

	// When we start a producer span
	ctx, span := StartProducerSpan(context.Background(), testTopic)
	span.End()

	// Then a span should be recorded
	spans := sr.Ended()
	require.Len(t, spans, 1)

	recordedSpan := spans[0]
	assert.Equal(t, "produce "+testTopic, recordedSpan.Name())
	assert.NotNil(t, ctx)
}

func TestExtractContext(t *testing.T) {
	// Given headers with trace context
	headers := []*sarama.RecordHeader{
		{
			Key:   []byte("traceparent"),
			Value: []byte("00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
		},
	}

	// When we extract context
	ctx := ExtractContext(context.Background(), headers)

	// Then context should be returned (with or without span context based on propagator)
	assert.NotNil(t, ctx)
}

func TestInjectContext(t *testing.T) {
	sr, cleanup := setupTestTracer(t)
	defer cleanup()

	// Given a context with active span
	ctx, span := StartProducerSpan(context.Background(), testTopic)
	defer span.End()

	// When we inject context into headers
	headers := InjectContext(ctx)

	// Then headers should contain trace context and x-obs-* headers
	hasXObsHeader := false
	for _, h := range headers {
		if string(h.Key) == "x-obs-dataproduct-urn" {
			hasXObsHeader = true
			assert.Equal(t, testServiceURN, string(h.Value))
		}
	}
	assert.True(t, hasXObsHeader, "x-obs-dataproduct-urn header should be present")

	_ = sr // Avoid unused variable warning
}

func TestHeadersCarrier(t *testing.T) {
	t.Run("Get returns header value", func(t *testing.T) {
		carrier := HeadersCarrier{
			{Key: []byte("key1"), Value: []byte("value1")},
			{Key: []byte("key2"), Value: []byte("value2")},
		}

		assert.Equal(t, "value1", carrier.Get("key1"))
		assert.Equal(t, "value2", carrier.Get("key2"))
		assert.Equal(t, "", carrier.Get("nonexistent"))
	})

	t.Run("Set appends header", func(t *testing.T) {
		carrier := HeadersCarrier{}
		carrier.Set("key1", "value1")

		assert.Len(t, carrier, 1)
		assert.Equal(t, "value1", carrier.Get("key1"))
	})

	t.Run("Keys returns all header keys", func(t *testing.T) {
		carrier := HeadersCarrier{
			{Key: []byte("key1"), Value: []byte("value1")},
			{Key: []byte("key2"), Value: []byte("value2")},
		}

		keys := carrier.Keys()
		assert.Contains(t, keys, "key1")
		assert.Contains(t, keys, "key2")
	})
}

func TestInstrumentedSyncProducer(t *testing.T) {
	sr, cleanup := setupTestTracer(t)
	defer cleanup()

	// Create mock producer
	mockProducer := &mockSyncProducer{
		partition: 1,
		offset:    200,
	}

	// Wrap with instrumentation
	producer := WrapSyncProducer(mockProducer)

	// Send message
	msg := &sarama.ProducerMessage{
		Topic: testTopic,
		Key:   sarama.StringEncoder("key"),
		Value: sarama.StringEncoder("value"),
	}

	partition, offset, err := producer.SendMessage(context.Background(), msg)

	// Verify
	assert.NoError(t, err)
	assert.Equal(t, int32(1), partition)
	assert.Equal(t, int64(200), offset)

	// Verify span was created
	spans := sr.Ended()
	require.Len(t, spans, 1)
	assert.Equal(t, "produce "+testTopic, spans[0].Name())

	// Verify headers were injected
	assert.NotEmpty(t, msg.Headers)
}

// mockSyncProducer is a mock implementation for testing
type mockSyncProducer struct {
	partition int32
	offset    int64
	err       error
}

func (m *mockSyncProducer) SendMessage(msg *sarama.ProducerMessage) (int32, int64, error) {
	return m.partition, m.offset, m.err
}

func (m *mockSyncProducer) SendMessages(msgs []*sarama.ProducerMessage) error {
	return m.err
}

func (m *mockSyncProducer) Close() error {
	return nil
}

func (m *mockSyncProducer) TxnStatus() sarama.ProducerTxnStatusFlag {
	return 0
}

func (m *mockSyncProducer) IsTransactional() bool {
	return false
}

func (m *mockSyncProducer) BeginTxn() error {
	return nil
}

func (m *mockSyncProducer) CommitTxn() error {
	return nil
}

func (m *mockSyncProducer) AbortTxn() error {
	return nil
}

func (m *mockSyncProducer) AddOffsetsToTxn(offsets map[string][]*sarama.PartitionOffsetMetadata, groupId string) error {
	return nil
}

func (m *mockSyncProducer) AddMessageToTxn(msg *sarama.ConsumerMessage, groupId string, metadata *string) error {
	return nil
}
