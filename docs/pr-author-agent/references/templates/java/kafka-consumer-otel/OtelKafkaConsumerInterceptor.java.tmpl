package com.company.${NAMESPACE}.${MODULE_NAME}.otel;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.SpanKind;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Context;
import io.opentelemetry.context.Scope;
import io.opentelemetry.context.propagation.TextMapGetter;
import org.apache.kafka.clients.consumer.ConsumerInterceptor;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.OffsetAndMetadata;
import org.apache.kafka.common.TopicPartition;
import org.apache.kafka.common.header.Headers;

import java.nio.charset.StandardCharsets;
import java.util.Map;

/**
 * OpenTelemetry interceptor for Kafka consumers in ${SERVICE_NAME}.
 *
 * This interceptor:
 * - Extracts trace context from Kafka headers
 * - Creates consumer spans for message processing
 * - Propagates correlation IDs (x-obs-*)
 *
 * Service URN: ${SERVICE_URN}
 * Generated by: Instrumentation Autopilot
 * Diff Plan ID: ${DIFF_PLAN_ID}
 */
public class OtelKafkaConsumerInterceptor<K, V> implements ConsumerInterceptor<K, V> {

    private static final String SERVICE_NAME = "${SERVICE_NAME}";
    private static final String CONSUMER_GROUP = "${CONSUMER_GROUP}";
    private static final String INPUT_TOPIC = "${INPUT_TOPIC}";

    private Tracer tracer;
    private OpenTelemetry openTelemetry;

    private static final TextMapGetter<Headers> GETTER = new TextMapGetter<>() {
        @Override
        public Iterable<String> keys(Headers carrier) {
            return () -> java.util.stream.StreamSupport
                .stream(carrier.spliterator(), false)
                .map(h -> h.key())
                .iterator();
        }

        @Override
        public String get(Headers carrier, String key) {
            var header = carrier.lastHeader(key);
            return header != null ? new String(header.value(), StandardCharsets.UTF_8) : null;
        }
    };

    @Override
    public void configure(Map<String, ?> configs) {
        // OpenTelemetry should be injected or obtained from GlobalOpenTelemetry
        this.openTelemetry = io.opentelemetry.api.GlobalOpenTelemetry.get();
        this.tracer = openTelemetry.getTracer(SERVICE_NAME, "${OTEL_VERSION}");
    }

    @Override
    public ConsumerRecords<K, V> onConsume(ConsumerRecords<K, V> records) {
        records.forEach(record -> {
            // Extract context from headers
            Context extractedContext = openTelemetry.getPropagators()
                .getTextMapPropagator()
                .extract(Context.current(), record.headers(), GETTER);

            // Create consumer span
            Span span = tracer.spanBuilder("consume " + record.topic())
                .setParent(extractedContext)
                .setSpanKind(SpanKind.CONSUMER)
                .setAttribute("messaging.system", "kafka")
                .setAttribute("messaging.destination", record.topic())
                .setAttribute("messaging.destination_kind", "topic")
                .setAttribute("messaging.kafka.partition", record.partition())
                .setAttribute("messaging.kafka.offset", record.offset())
                .setAttribute("messaging.kafka.consumer_group", CONSUMER_GROUP)
                .setAttribute("service.name", SERVICE_NAME)
                .setAttribute("service.namespace", "${NAMESPACE}")
                .startSpan();

            // Extract and propagate x-obs-* headers
            extractObservabilityHeaders(record.headers(), span);

            try (Scope scope = span.makeCurrent()) {
                // Record processing will happen in the actual consumer
            } finally {
                span.end();
            }
        });

        return records;
    }

    private void extractObservabilityHeaders(Headers headers, Span span) {
        // x-obs-dataproduct-urn
        var dpUrn = headers.lastHeader("x-obs-dataproduct-urn");
        if (dpUrn != null) {
            span.setAttribute("obs.dataproduct.urn", new String(dpUrn.value(), StandardCharsets.UTF_8));
        }

        // x-obs-trace-handoff-ids
        var handoffIds = headers.lastHeader("x-obs-trace-handoff-ids");
        if (handoffIds != null) {
            span.setAttribute("obs.trace.handoff_ids", new String(handoffIds.value(), StandardCharsets.UTF_8));
        }

        // x-obs-schema-id
        var schemaId = headers.lastHeader("x-obs-schema-id");
        if (schemaId != null) {
            span.setAttribute("obs.schema.id", new String(schemaId.value(), StandardCharsets.UTF_8));
        }
    }

    @Override
    public void onCommit(Map<TopicPartition, OffsetAndMetadata> offsets) {
        // Optional: Add span for commit operation
    }

    @Override
    public void close() {
        // Cleanup if needed
    }
}
