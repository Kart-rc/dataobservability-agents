"""
OpenTelemetry wrapper for Kafka clients in ${SERVICE_NAME}.

Service URN: ${SERVICE_URN}
Generated by: Instrumentation Autopilot
Diff Plan ID: ${DIFF_PLAN_ID}
"""

from typing import Any, Callable, Optional
from functools import wraps

from confluent_kafka import Consumer, Producer, Message
from opentelemetry import trace, propagate
from opentelemetry.trace import SpanKind, Status, StatusCode
from opentelemetry.semconv.trace import MessagingOperationValues
from opentelemetry.propagators.textmap import Getter, Setter

SERVICE_NAME = "${SERVICE_NAME}"
SERVICE_NAMESPACE = "${NAMESPACE}"
CONSUMER_GROUP = "${CONSUMER_GROUP}"
INPUT_TOPIC = "${INPUT_TOPIC}"
OUTPUT_TOPIC = "${OUTPUT_TOPIC}"
SERVICE_URN = "${SERVICE_URN}"

tracer = trace.get_tracer(SERVICE_NAME, "${OTEL_VERSION}")


class KafkaHeadersGetter(Getter):
    """Extract trace context from Kafka message headers."""

    def get(self, carrier: Message, key: str) -> Optional[str]:
        headers = carrier.headers() or []
        for header_key, header_value in headers:
            if header_key == key:
                return header_value.decode("utf-8") if header_value else None
        return None

    def keys(self, carrier: Message) -> list[str]:
        headers = carrier.headers() or []
        return [key for key, _ in headers]


class KafkaHeadersSetter(Setter):
    """Inject trace context into Kafka message headers."""

    def set(self, carrier: list, key: str, value: str) -> None:
        carrier.append((key, value.encode("utf-8")))


kafka_getter = KafkaHeadersGetter()
kafka_setter = KafkaHeadersSetter()


def extract_context(message: Message) -> trace.Context:
    """Extract trace context from a Kafka message."""
    return propagate.extract(message, getter=kafka_getter)


def inject_context(ctx: trace.Context) -> list[tuple[str, bytes]]:
    """Inject trace context into Kafka headers."""
    headers = []
    propagate.inject(headers, setter=kafka_setter, context=ctx)

    # Add x-obs-* headers
    headers.append(("x-obs-dataproduct-urn", SERVICE_URN.encode("utf-8")))

    return headers


def trace_consumer(func: Callable) -> Callable:
    """
    Decorator to trace Kafka consumer message processing.

    Usage:
        @trace_consumer
        def process_message(message: Message) -> None:
            # Process the message
            pass
    """
    @wraps(func)
    def wrapper(message: Message, *args, **kwargs):
        # Extract parent context from headers
        ctx = extract_context(message)

        with tracer.start_as_current_span(
            f"consume {message.topic()}",
            context=ctx,
            kind=SpanKind.CONSUMER,
            attributes={
                "messaging.system": "kafka",
                "messaging.destination": message.topic(),
                "messaging.destination_kind": "topic",
                "messaging.kafka.partition": message.partition(),
                "messaging.kafka.offset": message.offset(),
                "messaging.kafka.consumer_group": CONSUMER_GROUP,
                "service.name": SERVICE_NAME,
                "service.namespace": SERVICE_NAMESPACE,
            }
        ) as span:
            # Extract x-obs-* headers
            headers = message.headers() or []
            for key, value in headers:
                if key.startswith("x-obs-"):
                    attr_name = f"obs.{key[6:]}"
                    span.set_attribute(attr_name, value.decode("utf-8"))

            try:
                result = func(message, *args, **kwargs)
                span.set_status(Status(StatusCode.OK))
                return result
            except Exception as e:
                span.set_status(Status(StatusCode.ERROR, str(e)))
                span.record_exception(e)
                raise

    return wrapper


def trace_producer(topic: str) -> Callable:
    """
    Decorator to trace Kafka producer message sending.

    Usage:
        @trace_producer("output-topic")
        def send_message(producer: Producer, key: str, value: bytes) -> None:
            producer.produce(topic, key=key, value=value, headers=headers)
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            with tracer.start_as_current_span(
                f"produce {topic}",
                kind=SpanKind.PRODUCER,
                attributes={
                    "messaging.system": "kafka",
                    "messaging.destination": topic,
                    "messaging.destination_kind": "topic",
                    "service.name": SERVICE_NAME,
                    "service.namespace": SERVICE_NAMESPACE,
                }
            ) as span:
                # Inject trace context into headers
                ctx = trace.get_current_span().get_span_context()
                headers = inject_context(trace.set_span_in_context(span))

                # Add headers to kwargs if not present
                if "headers" not in kwargs:
                    kwargs["headers"] = headers
                else:
                    kwargs["headers"].extend(headers)

                try:
                    result = func(*args, **kwargs)
                    span.set_status(Status(StatusCode.OK))
                    return result
                except Exception as e:
                    span.set_status(Status(StatusCode.ERROR, str(e)))
                    span.record_exception(e)
                    raise

        return wrapper
    return decorator


class InstrumentedConsumer:
    """
    Instrumented Kafka Consumer with automatic tracing.

    Usage:
        consumer = InstrumentedConsumer(config)
        consumer.subscribe([INPUT_TOPIC])

        for message in consumer.poll_messages():
            process(message)  # Automatic span created
    """

    def __init__(self, config: dict[str, Any]):
        self._consumer = Consumer(config)

    def subscribe(self, topics: list[str]) -> None:
        self._consumer.subscribe(topics)

    def poll_messages(self, timeout: float = 1.0):
        """Poll for messages with automatic tracing."""
        while True:
            msg = self._consumer.poll(timeout)
            if msg is None:
                continue
            if msg.error():
                # Handle error
                continue

            # Create span for message consumption
            ctx = extract_context(msg)
            with tracer.start_as_current_span(
                f"consume {msg.topic()}",
                context=ctx,
                kind=SpanKind.CONSUMER,
                attributes={
                    "messaging.system": "kafka",
                    "messaging.destination": msg.topic(),
                    "messaging.kafka.partition": msg.partition(),
                    "messaging.kafka.offset": msg.offset(),
                    "messaging.kafka.consumer_group": CONSUMER_GROUP,
                }
            ):
                yield msg

    def close(self) -> None:
        self._consumer.close()


class InstrumentedProducer:
    """
    Instrumented Kafka Producer with automatic tracing.

    Usage:
        producer = InstrumentedProducer(config)
        producer.produce(OUTPUT_TOPIC, key=key, value=value)
        producer.flush()
    """

    def __init__(self, config: dict[str, Any]):
        self._producer = Producer(config)

    def produce(
        self,
        topic: str,
        key: Optional[bytes] = None,
        value: Optional[bytes] = None,
        headers: Optional[list[tuple[str, bytes]]] = None,
        **kwargs
    ) -> None:
        """Produce a message with automatic tracing."""
        with tracer.start_as_current_span(
            f"produce {topic}",
            kind=SpanKind.PRODUCER,
            attributes={
                "messaging.system": "kafka",
                "messaging.destination": topic,
                "service.name": SERVICE_NAME,
            }
        ) as span:
            # Inject trace context
            trace_headers = inject_context(trace.set_span_in_context(span))

            if headers:
                trace_headers.extend(headers)

            self._producer.produce(
                topic,
                key=key,
                value=value,
                headers=trace_headers,
                **kwargs
            )

    def flush(self, timeout: float = 10.0) -> int:
        return self._producer.flush(timeout)

    def close(self) -> None:
        self._producer.flush()
